import java.util.*;
import javax.swing.JOptionPane;

/**
 * Representa la simulaci√≥n de la Ruta de la Seda,
 * donde se administran tiendas y robots dentro de un tablero en espiral.
 */
public class SilkRoad {
    private final int length;
    private final List<Store> stores;
    private final List<Robot> robots;
    private boolean ok;
    private final SpiralRoad spiral;
    private final ProgressBar progressBar;
    private boolean silentMode = false;

    /**
     * Crea una nueva simulaci√≥n con una espiral de la longitud indicada.
     */
    public SilkRoad(int length) {
        this.spiral = new SpiralRoad(length);
        spiral.draw();
        this.length = spiral.getNumberOfCells();
        this.stores = new ArrayList<>();
        this.robots = new ArrayList<>();
        this.ok = true;
        this.progressBar = new ProgressBar(stores, robots);
        progressBar.makeVisible();
        showMessage("‚úÖ SilkRoad inicializado con " + this.length + " celdas.");
    }

    /**
     * Constructor que crea una ruta de seda a partir de la entrada tipo marat√≥n.
     */
    public SilkRoad(int[][] days) {
        int maxLocation = 0;
        for (int[] d : days) {
            int location = d[1];
            maxLocation = Math.max(maxLocation, location);
        }
        this.spiral = new SpiralRoad(maxLocation + 5);
        spiral.draw();
        this.length = spiral.getNumberOfCells();
        this.stores = new ArrayList<>();
        this.robots = new ArrayList<>();
        this.ok = true;
        this.progressBar = new ProgressBar(stores, robots);
        progressBar.makeVisible();

        for (int[] d : days) {
            int t = d[0], x = d[1];
            if (t == 1) {
                placeRobot(x);
                showMessage("ü§ñ Robot colocado en " + x);
            } else if (t == 2 && d.length == 3) {
                placeStore(x, d[2]);
                showMessage("üè™ Tienda colocada en " + x + " con " + d[2] + " tenges.");
            }
            showMessage("üí∞ Ganancia acumulada: " + profit());
        }
    }

    /**
     * Activa o desactiva el modo silencioso (sin di√°logos JOptionPane).
     */
    public void setSilentMode(boolean silent) {
        this.silentMode = silent;
    }

    /**
     * Muestra un mensaje solo si no est√° en modo silencioso.
     */
    private void showMessage(String message) {
        if (!silentMode) {
            JOptionPane.showMessageDialog(null, message);
        }
    }

    /**
     * Coloca una tienda en la ubicaci√≥n indicada con la cantidad de tenges especificada.
     */
    public void placeStore(int location, int tenges) {
        for (Store s : stores) {
            if (s.getLocation() == location) {
                ok = false;
                return;
            }
        }
        Store newStore = new Store(location, tenges);
        stores.add(newStore);
        stores.sort(Comparator.comparingInt(Store::getLocation));
        newStore.makeVisible();
        progressBar.update();
        ok = true;
    }

    /**
     * Elimina la tienda de la ubicaci√≥n indicada.
     */
    public void removeStore(int location) {
        Store toRemove = stores.stream().filter(s -> s.getLocation() == location).findFirst().orElse(null);
        if (toRemove != null) {
            stores.remove(toRemove);
            toRemove.makeInvisible();
            progressBar.update();
            showMessage("‚ùå Tienda eliminada en " + location);
            ok = true;
        } else {
            showMessage("‚ö† No existe tienda en " + location);
            ok = false;
        }
    }

    /**
     * Coloca un robot en la ubicaci√≥n indicada.
     */
    public void placeRobot(int location) {
        for (Robot r : robots) {
            if (r.getInitialLocation() == location) {
                ok = false;
                return;
            }
        }
        Robot newRobot = new Robot(location);
        robots.add(newRobot);
        robots.sort(Comparator.comparingInt(Robot::getInitialLocation));
        newRobot.makeVisible();
        ok = true;
    }

    /**
     * Elimina un robot de la ubicaci√≥n indicada.
     */
    public void removeRobot(int location) {
        Robot toRemove = robots.stream().filter(r -> r.getLocation() == location).findFirst().orElse(null);
        if (toRemove != null) {
            robots.remove(toRemove);
            toRemove.makeInvisible();
            showMessage("‚ùå Robot eliminado en " + location);
            ok = true;
        } else {
            showMessage("‚ö† No existe robot en " + location);
            ok = false;
        }
    }

    /**
     * Mueve todos los robots buscando maximizar la ganancia neta.
     * Usa el mismo algoritmo DP que profit() para calcular rutas √≥ptimas multi-tienda.
     */
    public void moveRobots() {
        int R = robots.size();
        int S = stores.size();
        if (R == 0 || S == 0) {
            ok = true;
            return;
        }

        // Obtener ubicaciones de robots ordenadas
        List<Integer> robotLocs = new ArrayList<>();
        List<Robot> sortedRobots = new ArrayList<>();
        for (Robot r : robots) {
            robotLocs.add(r.getInitialLocation());
            sortedRobots.add(r);
        }
        sortedRobots.sort(Comparator.comparingInt(Robot::getInitialLocation));

        // Obtener tiendas ordenadas por ubicaci√≥n
        List<Store> sortedStores = new ArrayList<>(stores);
        sortedStores.sort(Comparator.comparingInt(Store::getLocation));

        // Arrays de posiciones y valores
        int[] x = new int[S + 1];
        int[] c = new int[S + 1];
        long[] pref = new long[S + 1];

        for (int i = 1; i <= S; i++) {
            x[i] = sortedStores.get(i - 1).getLocation();
            c[i] = sortedStores.get(i - 1).getOriginalTenges();
            pref[i] = pref[i - 1] + c[i];
        }

        // dp[rIdx][j] = mejor ganancia usando robots[0..rIdx] y tiendas[1..j]
        long[][] dp = new long[R + 1][S + 1];
        int[][] choice = new int[R + 1][S + 1]; // Para reconstruir la soluci√≥n

        for (int rIdx = 0; rIdx <= R; rIdx++) Arrays.fill(dp[rIdx], 0L);
        for (int rIdx = 0; rIdx <= R; rIdx++) Arrays.fill(choice[rIdx], -1);

        for (int rIdx = 1; rIdx <= R; rIdx++) {
            int rr = robotLocs.get(rIdx - 1);

            for (int j = 1; j <= S; j++) {
                // Opci√≥n 1: no usar la tienda j
                long best = dp[rIdx][j - 1];
                choice[rIdx][j] = -1; // No usar tienda j

                // Opci√≥n 2: asignar al robot rIdx un intervalo [i..j]
                for (int i = j; i >= 1; i--) {
                    long sum = pref[j] - pref[i - 1];
                    int span = x[j] - x[i];
                    int attach = Math.min(Math.abs(rr - x[i]), Math.abs(rr - x[j]));
                    long gain = sum - (span + attach);
                    long candidate = dp[rIdx - 1][i - 1] + Math.max(0L, gain);
                    
                    if (candidate > best) {
                        best = candidate;
                        choice[rIdx][j] = i; // Robot rIdx toma intervalo [i..j]
                    }
                }

                dp[rIdx][j] = best;
            }
        }

        // Reconstruir la soluci√≥n y mover robots visualmente
        List<RobotAssignment> assignments = new ArrayList<>();
        int currentJ = S;
        
        for (int rIdx = R; rIdx >= 1; rIdx--) {
            while (currentJ > 0 && choice[rIdx][currentJ] == -1) {
                currentJ--;
            }
            
            if (currentJ > 0 && choice[rIdx][currentJ] > 0) {
                int startStore = choice[rIdx][currentJ];
                int endStore = currentJ;
                assignments.add(new RobotAssignment(rIdx - 1, startStore - 1, endStore - 1));
                currentJ = startStore - 1;
            }
        }

        // Invertir para procesar en orden correcto
        Collections.reverse(assignments);

        // Ejecutar los movimientos visualmente
        for (RobotAssignment assign : assignments) {
            Robot robot = sortedRobots.get(assign.robotIdx);
            
            // Mover el robot por cada tienda en el intervalo
            for (int storeIdx = assign.startStoreIdx; storeIdx <= assign.endStoreIdx; storeIdx++) {
                Store store = sortedStores.get(storeIdx);
                int storeLocation = store.getLocation();
                int tenges = store.getTenges();
                
                if (tenges > 0) {
                    robot.moveToStore(storeLocation, tenges);
                    showMessage("ü§ñ Robot movido a tienda en " + storeLocation);
                    store.empty();
                    
                    try {
                        Thread.sleep(300); // Pausa para visualizaci√≥n
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            }
        }

        robots.stream().max(Comparator.comparingInt(Robot::getTotalProfit))
                .ifPresent(r -> r.blink(4, 150));

        progressBar.update();
        ok = true;
    }

    /**
     * Clase auxiliar para almacenar asignaciones de robot a tiendas
     */
    private static class RobotAssignment {
        int robotIdx;
        int startStoreIdx;
        int endStoreIdx;

        RobotAssignment(int robotIdx, int startStoreIdx, int endStoreIdx) {
            this.robotIdx = robotIdx;
            this.startStoreIdx = startStoreIdx;
            this.endStoreIdx = endStoreIdx;
        }
    }

    /**
     * Mueve un robot manualmente desde su ubicaci√≥n actual.
     */
    public void moveRobot(int location, int meters) {
        Robot robotToMove = findRobotAt(location);
        if (robotToMove == null) {
            showNoRobotWarning(location);
            ok = false;
            return;
        }

        int newLocation = location + meters;
        if (isOutOfBounds(newLocation)) {
            showOutOfBoundsWarning();
            ok = false;
            return;
        }

        Store targetStore = findStoreAt(newLocation);

        if (targetStore != null) {
            moveRobotToStore(robotToMove, newLocation, targetStore);
        } else {
            moveRobotToEmptyLocation(robotToMove, newLocation);
        }

        blinkBestRobot();
        progressBar.update();
        ok = true;
    }

    private Robot findRobotAt(int location) {
        return robots.stream()
                .filter(r -> r.getLocation() == location)
                .findFirst()
                .orElse(null);
    }

    private void showNoRobotWarning(int location) {
        showMessage("‚ö† No hay robot en la ubicaci√≥n " + location);
    }

    private boolean isOutOfBounds(int location) {
        return location < 0 || location >= length;
    }

    private void showOutOfBoundsWarning() {
        showMessage("‚ö† Movimiento fuera de los l√≠mites (0 - " + (length - 1) + ")");
    }

    private Store findStoreAt(int location) {
        return stores.stream()
                .filter(s -> s.getLocation() == location && s.getTenges() > 0)
                .findFirst()
                .orElse(null);
    }

    private void moveRobotToStore(Robot robot, int location, Store store) {
        int tenges = store.getTenges();
        robot.moveToStore(location, tenges);
        store.empty();
    }

    private void moveRobotToEmptyLocation(Robot robot, int location) {
        robot.moveToStore(location, 0);
    }

    private void blinkBestRobot() {
        robots.stream()
                .max(Comparator.comparingInt(Robot::getTotalProfit))
                .ifPresent(r -> r.blink(4, 150));
    }

    /**
     * Reabastece todas las tiendas.
     */
    public void resupplyStores() {
        for (Store s : stores) {
            s.resupply();
            showMessage("üîÑ Tienda en " + s.getLocation() + " reabastecida.");
        }
        progressBar.update();
        ok = true;
    }

    /**
     * Devuelve todos los robots a su posici√≥n inicial.
     */
    public void returnRobots() {
        for (Robot r : robots) {
            r.returnToStart();
        }
        showMessage("‚Ü© Todos los robots regresaron a su posici√≥n inicial.");
        ok = true;
    }

    /**
     * Reinicia el simulador al inicio de un nuevo d√≠a.
     */
    public void reboot() {
        StringBuilder resumen = new StringBuilder("üìä Resumen de tiendas antes del reinicio:\n");

        for (Store s : stores) {
            resumen.append(" - Tienda en ")
                    .append(s.getLocation())
                    .append(" fue vaciada ")
                    .append(s.getEmptiedCount())
                    .append(" veces, entreg√≥ un total de ")
                    .append(s.getTotalGiven())
                    .append(" tenges.\n");

            s.resupply();
        }

        for (Robot r : robots) {
            r.resetDay();
        }
        progressBar.update();
        showMessage(resumen + "\nüåÖ Nuevo d√≠a: tiendas resurtidas y robots reiniciados.");
        ok = true;
    }

    /**
     * Calcula la ganancia total √≥ptima usando programaci√≥n din√°mica.
     * Permite que cada robot visite m√∫ltiples tiendas en una ruta √≥ptima.
     */
    public int profit() {
        int R = robots.size();
        int S = stores.size();
        if (R == 0 || S == 0) return 0;

        // Obtener ubicaciones de robots ordenadas
        List<Integer> robotLocs = new ArrayList<>();
        for (Robot r : robots) {
            robotLocs.add(r.getInitialLocation());
        }
        Collections.sort(robotLocs);

        // Obtener tiendas ordenadas por ubicaci√≥n
        List<Store> sortedStores = new ArrayList<>(stores);
        sortedStores.sort(Comparator.comparingInt(Store::getLocation));

        // Arrays de posiciones y valores
        int[] x = new int[S + 1];
        int[] c = new int[S + 1];
        long[] pref = new long[S + 1]; // suma de valores para rangos

        for (int i = 1; i <= S; i++) {
            x[i] = sortedStores.get(i - 1).getLocation();
            c[i] = sortedStores.get(i - 1).getOriginalTenges();
            pref[i] = pref[i - 1] + c[i];
        }

        // dp[rIdx][j] = mejor ganancia usando robots[0..rIdx] y tiendas[1..j]
        long[][] dp = new long[R + 1][S + 1];
        for (int rIdx = 0; rIdx <= R; rIdx++) Arrays.fill(dp[rIdx], 0L);

        for (int rIdx = 1; rIdx <= R; rIdx++) {
            int rr = robotLocs.get(rIdx - 1);

            for (int j = 1; j <= S; j++) {
                // Opci√≥n 1: no usar la tienda j
                long best = dp[rIdx][j - 1];

                // Opci√≥n 2: asignar al robot rIdx un intervalo [i..j]
                long bestInterval = Long.MIN_VALUE;
                for (int i = j; i >= 1; i--) {
                    long sum = pref[j] - pref[i - 1]; // recompensa de i..j
                    int span = x[j] - x[i];
                    int attach = Math.min(Math.abs(rr - x[i]), Math.abs(rr - x[j]));
                    long gain = sum - (span + attach);
                    long candidate = dp[rIdx - 1][i - 1] + Math.max(0L, gain);
                    if (candidate > bestInterval) bestInterval = candidate;
                }

                if (bestInterval > best) best = bestInterval;
                dp[rIdx][j] = best;
            }
        }

        long ans = dp[R][S];
        // El resultado es entero por entradas enteras, acotar a int de forma segura
        if (ans < Integer.MIN_VALUE) return Integer.MIN_VALUE;
        if (ans > Integer.MAX_VALUE) return Integer.MAX_VALUE;
        return (int) ans;
    }

    /**
     * Obtiene los datos de todas las tiendas.
     */
    public int[][] stores() {
        int[][] data = new int[stores.size()][2];
        for (int i = 0; i < stores.size(); i++) {
            data[i][0] = stores.get(i).getLocation();
            data[i][1] = stores.get(i).getTenges();
        }
        return data;
    }

    /**
     * Obtiene los datos de todas las tiendas que han sido vaciadas.
     */
    public int[][] emptiedStores() {
        List<int[]> res = new ArrayList<>();
        for (Store s : stores) {
            int[] storeData = new int[]{s.getLocation(), s.getEmptiedCount()};
            res.add(storeData);
        }
        res.sort(Comparator.comparingInt(a -> a[0]));
        return res.toArray(new int[0][0]);
    }

    /**
     * Obtiene los datos de todos los robots.
     */
    public int[][] robots() {
        int[][] data = new int[robots.size()][1];
        for (int i = 0; i < robots.size(); i++) {
            int initialLocation = robots.get(i).getInitialLocation();
            data[i][0] = initialLocation;
        }
        return data;
    }

    /**
     * Obtiene las ganancias por cada movimiento realizado por los robots.
     */
    public int[][] profitPerMove() {
        List<int[]> res = new ArrayList<>();
        for (Robot r : robots) {
            List<Integer> moves = r.getMoveProfits();
            int[] row = new int[moves.size() + 1];
            row[0] = r.getInitialLocation();
            for (int i = 0; i < moves.size(); i++) {
                int moveProfit = moves.get(i);
                row[i + 1] = moveProfit;
            }
            res.add(row);
        }
        res.sort(Comparator.comparingInt(a -> a[0]));
        return res.toArray(new int[0][0]);
    }

    /**
     * Hace visibles todos los componentes de la simulaci√≥n.
     */
    public void makeVisible() {
        spiral.makeVisible();
        for (Store s : stores) {
            s.makeVisible();
        }
        for (Robot r : robots) {
            r.makeVisible();
        }
        progressBar.makeVisible();
    }

    /**
     * Hace invisibles todos los componentes de la simulaci√≥n.
     */
    public void makeInvisible() {
        spiral.makeInvisible();
        for (Store s : stores) {
            s.makeInvisible();
        }
        for (Robot r : robots) {
            r.makeInvisible();
        }
        progressBar.makeInvisible();
    }

    /**
     * Finaliza la simulaci√≥n y cierra la aplicaci√≥n.
     */
    public void finish() {
        showMessage("üèÅ Fin del simulador.");
        System.exit(0);
    }

    /**
     * Verifica si la simulaci√≥n est√° en un estado v√°lido.
     */
    public boolean ok() {
        return ok;
    }
}
