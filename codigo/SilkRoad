import java.util.*;
import javax.swing.JOptionPane;

/**
 * Representa la simulaci√≥n de la Ruta de la Seda,
 * donde se administran tiendas y robots dentro de un tablero en espiral.
 */
public class SilkRoad {
    private final int length;
    private final List<Store> stores;
    private final List<Robot> robots;
    private boolean ok;
    private final SpiralRoad spiral;
    private final ProgressBar progressBar;
    private boolean silentMode = false;

    /**
     * Crea una nueva simulaci√≥n con una espiral de la longitud indicada.
     */
    public SilkRoad(int length) {
        this.spiral = new SpiralRoad(length);
        spiral.draw();
        this.length = spiral.getNumberOfCells();
        this.stores = new ArrayList<>();
        this.robots = new ArrayList<>();
        this.ok = true;
        this.progressBar = new ProgressBar(stores, robots);
        progressBar.makeVisible();
        showMessage("‚úÖ SilkRoad inicializado con " + this.length + " celdas.");
    }

    /**
     * Constructor que crea una ruta de seda a partir de la entrada tipo marat√≥n.
     */
    public SilkRoad(int[][] days) {
        int maxLocation = 0;
        for (int[] d : days) {
            int location = d[1];
            maxLocation = Math.max(maxLocation, location);
        }
        this.spiral = new SpiralRoad(maxLocation + 5);
        spiral.draw();
        this.length = spiral.getNumberOfCells();
        this.stores = new ArrayList<>();
        this.robots = new ArrayList<>();
        this.ok = true;
        this.progressBar = new ProgressBar(stores, robots);
        progressBar.makeVisible();

        for (int[] d : days) {
            int t = d[0], x = d[1];
            if (t == 1) {
                placeRobot(x);
                showMessage("ü§ñ Robot colocado en " + x);
            } else if (t == 2 && d.length == 3) {
                placeStore(x, d[2]);
                showMessage("üè™ Tienda colocada en " + x + " con " + d[2] + " tenges.");
            }
            showMessage("üí∞ Ganancia acumulada: " + profit());
        }
    }

    /**
     * Activa o desactiva el modo silencioso (sin di√°logos JOptionPane).
     */
    public void setSilentMode(boolean silent) {
        this.silentMode = silent;
    }

    /**
     * Muestra un mensaje solo si no est√° en modo silencioso.
     */
    private void showMessage(String message) {
        if (!silentMode) {
            JOptionPane.showMessageDialog(null, message);
        }
    }

    /**
     * Coloca una tienda en la ubicaci√≥n indicada con la cantidad de tenges especificada.
     */
    public void placeStore(int location, int tenges) {
        for (Store s : stores) {
            if (s.getLocation() == location) {
                ok = false;
                return;
            }
        }
        Store newStore = new Store(location, tenges);
        stores.add(newStore);
        stores.sort(Comparator.comparingInt(Store::getLocation));
        newStore.makeVisible();
        progressBar.update();
        ok = true;
    }

    /**
     * Elimina la tienda de la ubicaci√≥n indicada.
     */
    public void removeStore(int location) {
        Store toRemove = stores.stream().filter(s -> s.getLocation() == location).findFirst().orElse(null);
        if (toRemove != null) {
            stores.remove(toRemove);
            toRemove.makeInvisible();
            progressBar.update();
            showMessage("‚ùå Tienda eliminada en " + location);
            ok = true;
        } else {
            showMessage("‚ö† No existe tienda en " + location);
            ok = false;
        }
    }

    /**
     * Coloca un robot en la ubicaci√≥n indicada.
     */
    public void placeRobot(int location) {
        for (Robot r : robots) {
            if (r.getInitialLocation() == location) {
                ok = false;
                return;
            }
        }
        Robot newRobot = new Robot(location);
        robots.add(newRobot);
        robots.sort(Comparator.comparingInt(Robot::getInitialLocation));
        newRobot.makeVisible();
        ok = true;
    }

    /**
     * Elimina un robot de la ubicaci√≥n indicada.
     */
    public void removeRobot(int location) {
        Robot toRemove = robots.stream().filter(r -> r.getLocation() == location).findFirst().orElse(null);
        if (toRemove != null) {
            robots.remove(toRemove);
            toRemove.makeInvisible();
            showMessage("‚ùå Robot eliminado en " + location);
            ok = true;
        } else {
            showMessage("‚ö† No existe robot en " + location);
            ok = false;
        }
    }

    /**
     * Mueve todos los robots buscando maximizar la ganancia neta.
     * Usa un algoritmo greedy simple para visualizaci√≥n.
     */
    public void moveRobots() {
        Set<Store> disponibles = new HashSet<>();
        for (Store s : stores) {
            int tenges = s.getTenges();
            if (tenges > 0) {
                disponibles.add(s);
            }
        }

        while (true) {
            Robot bestR = null; 
            Store bestS = null; 
            int bestGain = 0;
            
            for (Robot r : robots) {
                for (Store s : disponibles) {
                    int gain = s.getTenges() - Math.abs(r.getLocation() - s.getLocation());
                    if (gain > bestGain) {
                        bestGain = gain; 
                        bestR = r; 
                        bestS = s;
                    }
                }
            }
            if (bestGain == 0) {
                break;
            }

            bestR.moveToStore(bestS.getLocation(), bestS.getTenges());
            showMessage("ü§ñ Robot movido a tienda en " + bestS.getLocation() +
                    " con ganancia " + bestGain);
            bestS.empty();
            disponibles.remove(bestS);
        }

        robots.stream().max(Comparator.comparingInt(Robot::getTotalProfit))
                .ifPresent(r -> r.blink(4, 150));

        progressBar.update();
        ok = true;
    }

    /**
     * Mueve un robot manualmente desde su ubicaci√≥n actual.
     */
    public void moveRobot(int location, int meters) {
        Robot robotToMove = findRobotAt(location);
        if (robotToMove == null) {
            showNoRobotWarning(location);
            ok = false;
            return;
        }

        int newLocation = location + meters;
        if (isOutOfBounds(newLocation)) {
            showOutOfBoundsWarning();
            ok = false;
            return;
        }

        Store targetStore = findStoreAt(newLocation);

        if (targetStore != null) {
            moveRobotToStore(robotToMove, newLocation, targetStore);
        } else {
            moveRobotToEmptyLocation(robotToMove, newLocation);
        }

        blinkBestRobot();
        progressBar.update();
        ok = true;
    }

    private Robot findRobotAt(int location) {
        return robots.stream()
                .filter(r -> r.getLocation() == location)
                .findFirst()
                .orElse(null);
    }

    private void showNoRobotWarning(int location) {
        showMessage("‚ö† No hay robot en la ubicaci√≥n " + location);
    }

    private boolean isOutOfBounds(int location) {
        return location < 0 || location >= length;
    }

    private void showOutOfBoundsWarning() {
        showMessage("‚ö† Movimiento fuera de los l√≠mites (0 - " + (length - 1) + ")");
    }

    private Store findStoreAt(int location) {
        return stores.stream()
                .filter(s -> s.getLocation() == location && s.getTenges() > 0)
                .findFirst()
                .orElse(null);
    }

    private void moveRobotToStore(Robot robot, int location, Store store) {
        int tenges = store.getTenges();
        robot.moveToStore(location, tenges);
        store.empty();
    }

    private void moveRobotToEmptyLocation(Robot robot, int location) {
        robot.moveToStore(location, 0);
    }

    private void blinkBestRobot() {
        robots.stream()
                .max(Comparator.comparingInt(Robot::getTotalProfit))
                .ifPresent(r -> r.blink(4, 150));
    }

    /**
     * Reabastece todas las tiendas.
     */
    public void resupplyStores() {
        for (Store s : stores) {
            s.resupply();
            showMessage("üîÑ Tienda en " + s.getLocation() + " reabastecida.");
        }
        progressBar.update();
        ok = true;
    }

    /**
     * Devuelve todos los robots a su posici√≥n inicial.
     */
    public void returnRobots() {
        for (Robot r : robots) {
            r.returnToStart();
        }
        showMessage("‚Ü© Todos los robots regresaron a su posici√≥n inicial.");
        ok = true;
    }

    /**
     * Reinicia el simulador al inicio de un nuevo d√≠a.
     */
    public void reboot() {
        StringBuilder resumen = new StringBuilder("üìä Resumen de tiendas antes del reinicio:\n");

        for (Store s : stores) {
            resumen.append(" - Tienda en ")
                    .append(s.getLocation())
                    .append(" fue vaciada ")
                    .append(s.getEmptiedCount())
                    .append(" veces, entreg√≥ un total de ")
                    .append(s.getTotalGiven())
                    .append(" tenges.\n");

            s.resupply();
        }

        for (Robot r : robots) {
            r.resetDay();
        }
        progressBar.update();
        showMessage(resumen + "\nüåÖ Nuevo d√≠a: tiendas resurtidas y robots reiniciados.");
        ok = true;
    }

    /**
     * Calcula la ganancia total de todos los robots.
     */
    public int profit() {
        return robots.stream().mapToInt(Robot::getTotalProfit).sum();
    }

    /**
     * Obtiene los datos de todas las tiendas.
     */
    public int[][] stores() {
        int[][] data = new int[stores.size()][2];
        for (int i = 0; i < stores.size(); i++) {
            data[i][0] = stores.get(i).getLocation();
            data[i][1] = stores.get(i).getTenges();
        }
        return data;
    }

    /**
     * Obtiene los datos de todas las tiendas que han sido vaciadas.
     */
    public int[][] emptiedStores() {
        List<int[]> res = new ArrayList<>();
        for (Store s : stores) {
            int[] storeData = new int[]{s.getLocation(), s.getEmptiedCount()};
            res.add(storeData);
        }
        res.sort(Comparator.comparingInt(a -> a[0]));
        return res.toArray(new int[0][0]);
    }

    /**
     * Obtiene los datos de todos los robots.
     */
    public int[][] robots() {
        int[][] data = new int[robots.size()][1];
        for (int i = 0; i < robots.size(); i++) {
            int initialLocation = robots.get(i).getInitialLocation();
            data[i][0] = initialLocation;
        }
        return data;
    }

    /**
     * Obtiene las ganancias por cada movimiento realizado por los robots.
     */
    public int[][] profitPerMove() {
        List<int[]> res = new ArrayList<>();
        for (Robot r : robots) {
            List<Integer> moves = r.getMoveProfits();
            int[] row = new int[moves.size() + 1];
            row[0] = r.getInitialLocation();
            for (int i = 0; i < moves.size(); i++) {
                int moveProfit = moves.get(i);
                row[i + 1] = moveProfit;
            }
            res.add(row);
        }
        res.sort(Comparator.comparingInt(a -> a[0]));
        return res.toArray(new int[0][0]);
    }

    /**
     * Hace visibles todos los componentes de la simulaci√≥n.
     */
    public void makeVisible() {
        spiral.makeVisible();
        for (Store s : stores) {
            s.makeVisible();
        }
        for (Robot r : robots) {
            r.makeVisible();
        }
        progressBar.makeVisible();
    }

    /**
     * Hace invisibles todos los componentes de la simulaci√≥n.
     */
    public void makeInvisible() {
        spiral.makeInvisible();
        for (Store s : stores) {
            s.makeInvisible();
        }
        for (Robot r : robots) {
            r.makeInvisible();
        }
        progressBar.makeInvisible();
    }

    /**
     * Finaliza la simulaci√≥n y cierra la aplicaci√≥n.
     */
    public void finish() {
        showMessage("üèÅ Fin del simulador.");
        System.exit(0);
    }

    /**
     * Verifica si la simulaci√≥n est√° en un estado v√°lido.
     */
    public boolean ok() {
        return ok;
    }
}
