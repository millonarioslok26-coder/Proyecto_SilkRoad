import java.util.*;
import javax.swing.JOptionPane;

/**
 * Representa la simulaci√≥n de la Ruta de la Seda,
 * donde se administran tiendas y robots dentro de un tablero en espiral.
 */
public class SilkRoad {
    private int length;
    private List<Store> stores;
    private List<Robot> robots;
    private boolean ok;
    private SpiralRoad spiral;
    private ProgressBar progressBar;

    /**
     * Crea una nueva simulaci√≥n con una espiral de la longitud indicada.
     *
     * @param length longitud de la espiral base
     */
    public SilkRoad(int length) {
        this.spiral = new SpiralRoad(length);
        spiral.draw();
        this.length = spiral.getNumberOfCells();
        this.stores = new ArrayList<>();
        this.robots = new ArrayList<>();
        this.ok = true;
        this.progressBar = new ProgressBar(stores, robots);
        progressBar.makeVisible();
        JOptionPane.showMessageDialog(null, "‚úÖ SilkRoad inicializado con " + this.length + " celdas.");
    }

    /**
     * Constructor que crea una ruta de seda a partir de la entrada tipo marat√≥n.
     * Este constructor se encarga de procesar un conjunto de eventos diarios 
     * en la simulaci√≥n y de realizar las operaciones correspondientes, 
     * como colocar robots y tiendas, y calcular la ganancia acumulada.
     * 
     * @param days matriz de eventos; cada fila {t, x} o {t, x, c}
     */
    public SilkRoad(int[][] days) {
        int maxLocation = 0;
        for (int[] d : days) {
            int location = d[1];
            maxLocation = Math.max(maxLocation, location);
        }
        this.spiral = new SpiralRoad(maxLocation + 5);
        spiral.draw();
        this.length = spiral.getNumberOfCells();
        this.stores = new ArrayList<>();
        this.robots = new ArrayList<>();
        this.ok = true;
        this.progressBar = new ProgressBar(stores, robots);
        progressBar.makeVisible();

        for (int[] d : days) {
            int t = d[0], x = d[1];
            if (t == 1) {
                placeRobot(x);
                JOptionPane.showMessageDialog(null, "ü§ñ Robot colocado en " + x);
            } else if (t == 2 && d.length == 3) {
                placeStore(x, d[2]);
                JOptionPane.showMessageDialog(null, "üè™ Tienda colocada en " + x + " con " + d[2] + " tenges.");
            }
            reboot();
            moveRobots();
            JOptionPane.showMessageDialog(null, "üí∞ Ganancia acumulada: " + profit());
        }
    }

    /**
     * Coloca una tienda en la ubicaci√≥n indicada con la cantidad de tenges especificada.
     * Si ya existe una tienda en esa ubicaci√≥n, no se realiza la operaci√≥n.
     * 
     * @param location ubicaci√≥n de la tienda en el tablero
     * @param tenges cantidad de tenges disponibles en la tienda
     */
    public void placeStore(int location, int tenges) {
        for (Store s : stores) {            
            if (s.getLocation() == location) { 
                ok = false; 
                return; 
            }
        }
        Store newStore = new Store(location, tenges);
        stores.add(newStore);
        stores.sort(Comparator.comparingInt(Store::getLocation));
        newStore.makeVisible();
        progressBar.update();
        ok = true;
    }

    /**
     * Elimina la tienda de la ubicaci√≥n indicada. Si no existe tienda en esa 
     * ubicaci√≥n, se notifica al usuario.
     * 
     * @param location ubicaci√≥n de la tienda a eliminar
     */
    public void removeStore(int location) {
        Store toRemove = stores.stream().filter(s -> s.getLocation() == location).findFirst().orElse(null);
        if (toRemove != null) {
            stores.remove(toRemove);
            toRemove.makeInvisible();
            progressBar.update();
            JOptionPane.showMessageDialog(null, "‚ùå Tienda eliminada en " + location);
            ok = true;
        } else {
            JOptionPane.showMessageDialog(null, "‚ö† No existe tienda en " + location);
            ok = false;
        }
    }

    /**
     * Coloca un robot en la ubicaci√≥n indicada. Si ya existe un robot en esa 
     * ubicaci√≥n, no se realiza la operaci√≥n.
     * 
     * @param location ubicaci√≥n inicial del robot
     */
    public void placeRobot(int location) {
        for (Robot r : robots) {
            if (r.getInitialLocation() == location) {
                ok = false;
                return;
            }
        }
        Robot newRobot = new Robot(location);
        robots.add(newRobot);
        robots.sort(Comparator.comparingInt(Robot::getInitialLocation));
        newRobot.makeVisible();
        ok = true;
    }

    /**
     * Elimina un robot de la ubicaci√≥n indicada. Si no existe robot en esa 
     * ubicaci√≥n, se notifica al usuario.
     * 
     * @param location ubicaci√≥n del robot a eliminar
     */
    public void removeRobot(int location) {
        Robot toRemove = robots.stream().filter(r -> r.getLocation() == location).findFirst().orElse(null);
        if (toRemove != null) {
            robots.remove(toRemove);
            toRemove.makeInvisible();
            JOptionPane.showMessageDialog(null, "‚ùå Robot eliminado en " + location);
            ok = true;
        } else {
            JOptionPane.showMessageDialog(null, "‚ö† No existe robot en " + location);
            ok = false;
        }
    }

    /**
     * Mueve todos los robots buscando maximizar la ganancia neta al mover
     * los robots a las tiendas con m√°s tenges disponibles.
     */
    public void moveRobots() {
        Set<Store> disponibles = new HashSet<>();
        for (Store s : stores) {
            int tenges = s.getTenges();
            if (tenges > 0) {
                disponibles.add(s);
            }
        }
        
        while (true) {
            Robot bestR = null; Store bestS = null; int bestGain = 0;
            for (Robot r : robots) {
                for (Store s : disponibles) {
                    int gain = s.getTenges() - Math.abs(r.getLocation() - s.getLocation());
                    if (gain > bestGain) {
                        bestGain = gain; bestR = r; bestS = s;
                    }
                }
            }
            if (bestGain <= 0 || bestR == null) {
                break;
            }

            bestR.moveToStore(bestS.getLocation(), bestS.getTenges());
            JOptionPane.showMessageDialog(null, "ü§ñ Robot movido a tienda en " + bestS.getLocation() +
                                                " con ganancia " + bestGain);
            bestS.empty();
            disponibles.remove(bestS);
        }

        robots.stream().max(Comparator.comparingInt(Robot::getTotalProfit))
              .ifPresent(r -> r.blink(4, 150));

        progressBar.update();
        ok = true;
    }

    /**
     * Mueve un robot manualmente desde su ubicaci√≥n actual una cantidad de celdas.
     * Si el robot llega a una tienda con tenges disponibles, recoge el dinero
     * (ganancia = valor tienda - distancia).
     * 
     * @param location ubicaci√≥n actual del robot
     * @param meters cantidad de celdas a mover el robot
     */
    public void moveRobot(int location, int meters) {
        Robot robotToMove = robots.stream()
            .filter(r -> r.getLocation() == location)
            .findFirst()
            .orElse(null);

        if (robotToMove == null) {
            JOptionPane.showMessageDialog(null, "‚ö† No hay robot en la ubicaci√≥n " + location);
            ok = false;
            return;
        }

        int newLocation = location + meters;
        if (newLocation < 0 || newLocation >= length) {
            JOptionPane.showMessageDialog(null, "‚ö† Movimiento fuera de los l√≠mites (0 - " + (length - 1) + ")");
            ok = false;
            return;
        }

        Store targetStore = stores.stream()
            .filter(s -> s.getLocation() == newLocation && s.getTenges() > 0)
            .findFirst()
            .orElse(null);

        if (targetStore != null) {
            int distance = Math.abs(newLocation - location);
            robotToMove.moveToStore(newLocation, targetStore.getTenges());
            targetStore.empty();
        } else {
            robotToMove.moveToStore(newLocation, 0);
        }

        robots.stream().max(Comparator.comparingInt(Robot::getTotalProfit))
              .ifPresent(r -> r.blink(4, 150));

        progressBar.update();
        ok = true;
    }

    /**
     * Reabastece todas las tiendas, restaurando la cantidad inicial de tenges
     * en cada una de ellas.
     */
    public void resupplyStores() {
        for (Store s : stores) {
            s.resupply();
            JOptionPane.showMessageDialog(null, "üîÑ Tienda en " + s.getLocation() + " reabastecida.");
        }
        progressBar.update();
        ok = true;
    }

    /**
     * Devuelve todos los robots a su posici√≥n inicial en el tablero.
     */
    public void returnRobots() {
        for (Robot r : robots) {
            r.returnToStart();
        }
        JOptionPane.showMessageDialog(null, "‚Ü© Todos los robots regresaron a su posici√≥n inicial.");
        ok = true;
    }

    /**
     * Reinicia el simulador al inicio de un nuevo d√≠a. Se muestra un resumen
     * de las tiendas antes del reinicio, y las tiendas son reabastecidas.
     */
    public void reboot() {
        StringBuilder resumen = new StringBuilder("üìä Resumen de tiendas antes del reinicio:\n");
    
        for (Store s : stores) {
            resumen.append(" - Tienda en ")
                   .append(s.getLocation())
                   .append(" fue vaciada ")
                   .append(s.getEmptiedCount())
                   .append(" veces, entreg√≥ un total de ")
                   .append(s.getTotalGiven())
                   .append(" tenges.\n");
    
            s.resupply();
        }
    
        for (Robot r : robots) {
            r.resetDay();
        }  
        progressBar.update();
        JOptionPane.showMessageDialog(null, resumen.toString() + "\nüåÖ Nuevo d√≠a: tiendas resurtidas y robots reiniciados.");
        ok = true;
    }

    /**
     * Calcula la ganancia total de todos los robots en la simulaci√≥n.
     * 
     * @return la ganancia total acumulada por todos los robots
     */
    public int profit() {
        return robots.stream().mapToInt(Robot::getTotalProfit).sum();
    }

    /**
     * Obtiene los datos de todas las tiendas, incluyendo su ubicaci√≥n y la cantidad 
     * de tenges disponibles en cada una.
     * 
     * @return una matriz bidimensional con las ubicaciones y tenges de todas las tiendas
     */
    public int[][] stores() {
        int[][] data = new int[stores.size()][2];
        for (int i = 0; i < stores.size(); i++) {
            data[i][0] = stores.get(i).getLocation();
            data[i][1] = stores.get(i).getTenges();
        }
        return data;
    }

    /**
     * Obtiene los datos de todas las tiendas que han sido vaciadas, incluyendo
     * su ubicaci√≥n y la cantidad de veces que fueron vaciadas.
     * 
     * @return una matriz bidimensional con las ubicaciones y la cantidad de veces que
     *         fueron vaciadas las tiendas
     */
    public int[][] emptiedStores() {
        List<int[]> res = new ArrayList<>();
        for (Store s : stores) {
            int[] storeData = new int[]{s.getLocation(), s.getEmptiedCount()};
            res.add(storeData);
        }        
        res.sort(Comparator.comparingInt(a -> a[0]));
        return res.toArray(new int[0][0]);
    }

    /**
     * Obtiene los datos de todos los robots, incluyendo su ubicaci√≥n inicial.
     * 
     * @return una matriz bidimensional con las ubicaciones iniciales de los robots
     */
    public int[][] robots() {
        int[][] data = new int[robots.size()][1];
        for (int i = 0; i < robots.size(); i++) {
            int initialLocation = robots.get(i).getInitialLocation();
            data[i][0] = initialLocation;
        }
        return data;
    }

    /**
     * Obtiene las ganancias por cada movimiento realizado por los robots.
     * 
     * @return una matriz bidimensional con la ubicaci√≥n inicial de los robots y las
     *         ganancias obtenidas por cada movimiento realizado
     */
    public int[][] profitPerMove() {
        List<int[]> res = new ArrayList<>();
        for (Robot r : robots) {
            List<Integer> moves = r.getMoveProfits();
            int[] row = new int[moves.size() + 1];
            row[0] = r.getInitialLocation();
            for (int i = 0; i < moves.size(); i++) {
                int moveProfit = moves.get(i);
                row[i + 1] = moveProfit;
            }
            res.add(row);
        }
        res.sort(Comparator.comparingInt(a -> a[0]));
        return res.toArray(new int[0][0]);
    }

    /**
     * Hace visibles todos los componentes de la simulaci√≥n (espiral, tiendas, robots y barra de progreso).
     */
    public void makeVisible() {
        spiral.makeVisible();
        for (Store s : stores) {
            s.makeVisible();
        }
        for (Robot r : robots) {
            r.makeVisible();
        }
        progressBar.makeVisible();
    }

    /**
     * Hace invisibles todos los componentes de la simulaci√≥n (espiral, tiendas, robots y barra de progreso).
     */
    public void makeInvisible() {
        spiral.makeInvisible();
        for (Store s : stores) {
            s.makeInvisible();
        }
        for (Robot r : robots) {
            r.makeInvisible();
        }
        progressBar.makeInvisible();
    }

    /**
     * Finaliza la simulaci√≥n y cierra la aplicaci√≥n.
     */
    public void finish() {
        JOptionPane.showMessageDialog(null, "üèÅ Fin del simulador.");
        System.exit(0);
    }

    /**
     * Verifica si la simulaci√≥n est√° en un estado v√°lido.
     * 
     * @return true si la simulaci√≥n est√° en un estado v√°lido, false de lo contrario
     */
    public boolean ok() { 
        return ok; 
    }
}
